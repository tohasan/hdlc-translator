package org.tohasan.hdlctranslator.hdlc;

import org.tohasan.hdlctranslator.common.entities.FrameItem;
import org.tohasan.hdlctranslator.common.entities.Package;
import org.tohasan.hdlctranslator.common.entities.impl.CommonFrame;
import org.tohasan.hdlctranslator.hdlc.items.*;

import java.util.Arrays;
import java.util.List;

/**
 * Структура HDLC пакета (сообщения):
 * FD (Frame Delimiter - <разделитель кадров>) – 1 байт, все HDLC кадры должны начинаться и заканчиваться полем флага "01111110" (0x7E).
 *      FF (Frame Format - <формат кадра>) – 2 байта:
 *          [15..12] биты – <Тип кадра> (FrameType), всегда "1010" (0xA). Возможные типы кадров: (I frame) READ REQUEST, (I frame) READ REASPONSE, (RR frame) RECEIVE READY,
 *          [11] – <Признак сегментирования кадра> (Segmentation). Возможные значения поля: 0 – единственный (последний) кадр, 1 – есть следующий кадр,
 *          [10..8] – не используются (RFU),
 *          [7..0] – <Длина кадра в байтах> (Length). При расчете длины кадра флаги начала и конца кадра не учитываются.
 *      AF (AddressField - <адресное поле>) – от 1 до 5 байт, определяет уникальные адреса получателя (DestinationAddress) и отправителя (SourceAddress), участвующих в передаче конкретного кадра. При взаимодействии сервером является прибор учета (Server), клиентом выступает радиомодуль (Client).
 *          <Адрес клиента> (ClientAddress) – 1 байт, значение идентифицирует клиента.
 *              Зарезервированные адреса клиента:
 *                  0x00 – Нет станции (No-station),
 *                  0x01 – Процесс управляется клиентом (Client Management Process),
 *                  0x10 – Общий доступ (Public Client – самый низкий уровень безопасности).
 *              Адрес клиента используется для выбора уровня доступа. При кодировании адреса клиента резервируется младший значащий бит, который затем устанавливается в единицу.
 *          <Адрес сервера> (ServerAddress) – состоит из двух частей,
 *              верхняя часть (upper part) – это <логический адрес устройства> (logical device address),
 *              нижняя часть (lower part) – это <физический адрес устройства> (physical device address).
 *          Возможны три варианта адресации сервера:
 *              Однобайтовая адресация (1 байт). Есть только верхний адрес (logical device address). В некоторых случаях, нижняя часть может быть опущена.
 *              Двухбайтовая адресация (2 байта). Есть верхний адрес (logical device address) – 1 байт и нижний адрес (physical device address) – 1 байт.
 *              Четырехбайтовая адресация (4 байта). Есть верхний адрес – 2 байта и нижний адрес – два байта.
 *          При кодировании адреса сервера резервируется младший значащий бит каждого байта (бит расширения), которые затем устанавливаются в ноль,
 *                                              и только младший значащий бит нижней части адреса устанавливается в единицу.
 *          Примечание: Адрес сервера может быть длиной 1, 2 или 4 байта.
 *                      Для адресации серверов используется метод расширенной адресации, при этом адрес сервера может быть разделен на «Верхний» и «Нижний».
 *                      «Верхний» адрес может быть адресом логического устройства внутри физического устройства,
 *                      а «нижний» – адресом физического устройства при многоточечной конфигурации сети.
 *                      «Верхний» адрес должен присутствовать обязательно, «Нижний» может отсутствовать.
 *                      Признаком наличия «Нижнего» адреса является нулевой младший бит в байте «Верхнего» адреса.
 *                      При однобайтовой адресации младший бит адреса должен быть установлен в «1»,
 *                      при многобайтовой адресации младшие биты всех байт, кроме последнего, должны быть установлены в «0», а у последнего – в «1».
 *                      Содержимое адреса располагается в старших 7 битах каждого адреса, таким образом, адресное пространство при 1 байтовой адресации составляет от 0х00 до 0х7F,
 *                                                                                                                           а при 2-х байтовой адресации – от 0х00 до 0х3FFF.
 *          Примечание: Верхняя и нижняя части адреса кодируются независимо друг от друга и уже в закодированном виде подставляются в поле адреса.
 *      CF (Control Field - <управляющее поле>) – 1 байт, задает тип команды или ответа, а также значения счетчиков, отправленных/принятых кадров,
 *          [7..5] биты – <значение счетчика принятых кадров> (RFNumber),
 *          [4] – <бит опроса/завершения> (PF – poll/final),
 *          [3..1] – <значение счетчика отправленных кадров> (SFNumber),
 *          [0] – <тип кадра> (FrameType).
 *          Возможные типы кадров и соответствующие им значения:
 *              0 – I – Информационный кадр (Information frame).
 *              1 – RR – Готов к приему (Receive ready)
 *              1 – RNR – Не готов к приему (Receive not ready)
 *              1 – SNRM – Установить режим нормального ответа (Set Normal Response Mode)
 *              1 – DISC – Разъединить (Disconnect)
 *              1 – UA – Ненумерованное подтверждение (Unnumbered Acknowledgment)
 *      HCS (Header Check Sequence - <код целостности заголовка>) – (2 байта).
 * <p>
 * Information Field (<Информационное поле>)
 * Максимальное значение длины информационного поля 2030 байт (значение по умолчанию 128 байт)
 * <p>
 * FCS (Frame Check Sequence - <код целостности HDLC кадра>) – 2 байта.
 * FD (Frame Delimiter - <разделитель кадров>) – 1 байт, все HDLC кадры должны начинаться и заканчиваться полем флага "01111110" (0x7E).
 * <p>
 * author: IgorKaSan
 * date: 04.03.2018.
 */
public class HdlcFrame extends CommonFrame {

    public HdlcFrame() {
        this.setItems(Arrays.asList(
            new FrameDelimiter(this),
            new FrameFormatDefinition(this),
            new Address(this),
            new Address(this),
            new ControlField(this),
            new HeaderCheckSequence(this),
            new InformationField(this),
            new FrameCheckSequence(this),
            new FrameDelimiter(this)
        ));
    }
}
